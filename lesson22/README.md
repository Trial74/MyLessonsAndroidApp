# Intent, Intent Filter, Context - теория

## теория по Intent и Intent Filter. Немного о Context

---

[На прошлом уроке](https://github.com/Trial74/MyLessonsAndroidApp/tree/master/lesson21) мы создали приложение, которое содержит два __Activity__. Напомню, что для создания __Activity__, необходимо:
- создать класс, с суперклассом __android.app.Activity__
- создать __Activity__ - запись в манифесте и указать ей созданный класс в поле Name

Надеюсь прошлый урок не вызвал особых трудностей и процедура создания __Activity__ примерно уложилась в голове. Теперь мы можем обратить внимание на код вызова __Activity__.

```Java
Intent intent = new Intent(this, ActivityTwo.class);
startActivity(intent);
```

Мы использовали объект __Intent__. О нем можно почитать [здесь](http://developer.android.com/guide/topics/fundamentals.html#ActivatingComponents), [здесь](http://developer.android.com/guide/topics/intents/intents-filters.html) и [здесь](http://developer.android.com/reference/android/content/Intent.html). Правда инфа достаточно сложна для понимания с нуля. Я попробую своими словами объяснить.

#### Что такое Intent
В нашем случае __Intent__ – это __объект__, в котором мы __прописываем, какое Activity__ нам необходимо __вызвать__. После чего мы передаем этот __Intent - объект__ методу __startActivity__, который находит __соответствующее Activity__ и показывает его. При создании __Intent__ мы использовали конструктор __Intent (Context packageContext, Class cls)__ с двумя параметрами.

Первый параметр – это [__Context__](http://developer.android.com/reference/android/content/Context.html). Если помните, когда мы программно создавали __View__ в одном из прошлых уроков, мы тоже использовали в конструкторах объект __Context__. __Activity__ является подклассом __Context__, поэтому мы можем использовать ее – __this__. Вкратце, __Context__ – это объект, который предоставляет доступ к базовым функциям приложения таким как: доступ к ресурсам, к файловой системе, вызов __Activiy__ и т.д. Я думаю, в дальнейшем мы рассмотрим примеры, где явно увидим, зачем Context передается и как используется.

Второй параметр – __имя класса__. Напомню, что при создании записи __Activity__ в манифест-файле мы указываем имя класса. И теперь если мы укажем тот же класс в __Intent__ – то система, просмотрев манифест-файл обнаружит соответствие и покажет соответствующий __Activity__.

В этом можно легко убедиться. Мы удалим запись об __Activity__ из __манифест-файла__ и попробуем его после этого вызвать. Откройте проект из [прошлого урока TwoActivity](https://github.com/Trial74/MyLessonsAndroidApp/blob/master/lesson21/src/main/java/com/example/lesson21/TwoActivity.java), откройте манифест-файл, вкладка __Application__ и удалите запись об __ActivityTwo__ с помощью кнопки __Remove__. Сохраните все, запустите приложение и попробуйте вызвать __Activity__ кнопкой __“Go to Activity Two”__. Приложение выдаст ошибку. Если посмотреть логи, то видим следующий текст:

_ERROR/AndroidRuntime(367): android.content.ActivityNotFoundException: Unable to find explicit activity class {ru.startandroid.develop.p0211twoactivity/ru.startandroid.develop.p0211twoactivity.ActivityTwo}; have you declared this activity in your AndroidManifest.xml?_

(__Логи__ - вкладка __LogCat__ в __Eclipse__. Если не видно такой, то идем в меню __Window -> Show View -> Other__, папка __Android -> LogCat__ )

Система говорит нам, что не нашла такого __Activity__ класса и любезно подсказывает, что, возможно, он не прописан в манифест-файле. Снова пропишите __Activity__ в __манифест-файле__, все сохраните и запускайте. Теперь должно работать.

Явный вызов
Вызов __Activity__ с помощью такого __Intent__ – это явный вызов. Т.е. с помощью класса мы явно указываем какое __Activity__ хотели бы увидеть. Это обычно используется внутри одного приложения. Схематично это можно изобразить так:

![ImageAlt](https://lh4.googleusercontent.com/-zJcXjNOv0wk/Ton0Jh7sU4I/AAAAAAAAAa4/8j80xc1nbGM/s800/20111003_L0022_L_ExplicitIntent.jpg)

Здесь мы создаем Intent, в качестве параметра передаем ему класс __Class_B__. Далее вызываем метод __startActivity__ с созданным __Intent__ в качестве параметра. Метод проверяет __AndroidManifest__ на наличие __Activity__ связанной с классом __Class_B__ и если находит, то отображает. Все это в пределах одного приложения.

### Неявный вызов
Существует также неявный вызов __Activity__. Он отличается тем, что при создании __Intent__ мы используем не класс, а заполняем параметры __action, data, category__ определенными значениями. Комбинация этих значений определяют цель, которую мы хотим достичь. Например: отправка письма, открытие гиперссылки, редактирование текста, просмотр картинки, звонок по определенному номеру и т.д. В свою очередь для __Activity__ мы прописываем __Intent Filter__ - это набор тех же параметров: __action, data, category__ (но значения уже свои - зависят от того, что умеет делать __Activity__). И если параметры нашего Intent совпадают с условиями этого фильтра, то __Activity__ вызывается. Но при этом поиск уже идет по всем __Activity__ всех приложений в системе. Если находится несколько, то система предоставляет вам выбор, какой именно программой вы хотите воспользоваться. Схематично это можно изобразить так:

![ImageAlt](https://lh4.googleusercontent.com/-uLJgLPXCzOg/Ton0Jjr0CZI/AAAAAAAAAa8/ThvAvfrju1g/s800/20111003_L0022_L_ImplicitIntent.jpg)

В __Application_1__ создается __Intent__, заполняются параметры __action, data, category__. Для удобства, получившийся набор параметров назовем __Param_C__. С помощью __startActivity__ этот __Intent__ отправляется на поиски подходящей __Activity__, которая сможет выполнить то, что нам нужно (т.е. то, что определено с помощью __Param_C__). В системе есть разные приложения, и в каждом из них несколько __Activity__. Для некоторых __Activity__ определен __Intent Filter__ (наборы __Param_A, Param_B__ и т.д.), для некоторых нет. Метод __startActivity__ сверяет набор параметров __Intent__ и наборы параметров __Intent Filter__ для каждой __Activity__. Если наборы совпадают (__Param_C__ для обоих), то __Activity__ считается подходящей.

Если в итоге нашлась только одна __Activity__ – она и отображается. Если же нашлось несколько подходящих __Activity__, то пользователю выводится список, где он может сам выбрать какое приложение ему использовать.

Например, если в системе установлено несколько музыкальных плееров, и вы запускаете mp3, то система выведет вам список __Activity__, которые умеют играть музыку и попросит выбрать, какое из них использовать. А те __Activity__, которые умеют редактить текст, показывать картинки, звонить и т.п. будут проигнорированы.

Если для __Activity__ не задан __Intent Filter__ (__Activity_24__ на схеме), то __Intent__ с параметрами ему никак не подойдет, и оно тоже будет проигнорировано.

Если проводить аналогии - можно сравнить __Intent__ с ключом, а __Intent Filter__ с замком, за которым сидит прекрасное __Activity__

Мы будем постепенно узнавать нюансы этого механизма и значения которыми заполняются параметры __action, data и category__ в __Intent__ и __Intent Filter__. Сейчас важно понять, что в случае неявного вызова одно приложение посылает __Intent__, а все другие сверяют его параметры со своими __Activity -> Intent Filter__. __Intent__ – это базовое понятие системы __Android__ и без него нам никуда. Оно применяется не только для __Activity__. Но об этом позднее.

Ну вот, хотел написать пару вводных слов, а получилось достаточно подробное объяснение со схемами и примерами. Надеюсь, что у меня получилось донести смысл технологии __Intent-ов__. В дальнейшем будем практиковаться и закрепим тему.

---

#### [Источник](https://startandroid.ru/ru/uroki/vse-uroki-spiskom/59-urok-22-intent-intent-filter-context-teorija.html)